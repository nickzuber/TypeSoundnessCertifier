Welcome to Abella 2.0.3
Abella < Specification "recursive".
Reading specification "recursive"

Abella < Theorem canonical_form_mu : 
forall E U1, {typeOf E (mu U1)} -> {value E} ->
  (exists Arg1 Arg2, E = fold Arg1 Arg2 /\ {value Arg1}).


============================
 forall E U1, {typeOf E (mu U1)} -> {value E} ->
   (exists Arg1 Arg2, E = fold Arg1 Arg2 /\ {value Arg1})

canonical_form_mu < intros Main Value.

Variables: E U1
Main : {typeOf E (mu U1)}
Value : {value E}
============================
 exists Arg1 Arg2, E = fold Arg1 Arg2 /\ {value Arg1}

canonical_form_mu < case Main.
Subgoal 1:

Variables: U1 E1
Value : {value (fold E1 U1)}
H1 : {typeOf E1 (U1 (mu U1))}
============================
 exists Arg1 Arg2, fold E1 U1 = fold Arg1 Arg2 /\ {value Arg1}

Subgoal 2 is:
 exists Arg1 Arg2, unfold E1 = fold Arg1 Arg2 /\ {value Arg1}

canonical_form_mu < case Value.
Subgoal 1:

Variables: U1 E1
H1 : {typeOf E1 (U1 (mu U1))}
H2 : {value E1}
============================
 exists Arg1 Arg2, fold E1 U1 = fold Arg1 Arg2 /\ {value Arg1}

Subgoal 2 is:
 exists Arg1 Arg2, unfold E1 = fold Arg1 Arg2 /\ {value Arg1}

canonical_form_mu < search.
Subgoal 2:

Variables: U1 R E1
Value : {value (unfold E1)}
H1 : R (mu R) = mu U1
H2 : {typeOf E1 (mu R)}
============================
 exists Arg1 Arg2, unfold E1 = fold Arg1 Arg2 /\ {value Arg1}

canonical_form_mu < case Value.
Proof completed.
Abella < Define progresses : term -> prop by 
progresses E := {value E};
progresses E := exists E', {step E E'}.

Abella < Theorem progress_fold : 
forall E1 U2 T, {typeOf (fold E1 U2) T} -> progresses E1 ->
  progresses (fold E1 U2).


============================
 forall E1 U2 T, {typeOf (fold E1 U2) T} -> progresses E1 ->
   progresses (fold E1 U2)

progress_fold < intros Main PrgsE1.

Variables: E1 U2 T
Main : {typeOf (fold E1 U2) T}
PrgsE1 : progresses E1
============================
 progresses (fold E1 U2)

progress_fold < TypeOfE1 : case Main.

Variables: E1 U2
PrgsE1 : progresses E1
TypeOfE1 : {typeOf E1 (U2 (mu U2))}
============================
 progresses (fold E1 U2)

progress_fold < ProgressClause : case PrgsE1.
Subgoal 1:

Variables: E1 U2
TypeOfE1 : {typeOf E1 (U2 (mu U2))}
ProgressClause : {value E1}
============================
 progresses (fold E1 U2)

Subgoal 2 is:
 progresses (fold E1 U2)

progress_fold < search.
Subgoal 2:

Variables: E1 U2 E'
TypeOfE1 : {typeOf E1 (U2 (mu U2))}
ProgressClause : {step E1 E'}
============================
 progresses (fold E1 U2)

progress_fold < search.
Proof completed.
Abella < Theorem progress_unfold : 
forall E1 T, {typeOf (unfold E1) T} -> progresses E1 ->
  progresses (unfold E1).


============================
 forall E1 T, {typeOf (unfold E1) T} -> progresses E1 ->
   progresses (unfold E1)

progress_unfold < intros Main PrgsE1.

Variables: E1 T
Main : {typeOf (unfold E1) T}
PrgsE1 : progresses E1
============================
 progresses (unfold E1)

progress_unfold < TypeOfE1 : case Main.

Variables: E1 R
PrgsE1 : progresses E1
TypeOfE1 : {typeOf E1 (mu R)}
============================
 progresses (unfold E1)

progress_unfold < ProgressClause : case PrgsE1.
Subgoal 1:

Variables: E1 R
TypeOfE1 : {typeOf E1 (mu R)}
ProgressClause : {value E1}
============================
 progresses (unfold E1)

Subgoal 2 is:
 progresses (unfold E1)

progress_unfold < Canonical : apply canonical_form_mu to TypeOfE1 ProgressClause.
Subgoal 1:

Variables: R Arg1 Arg2
TypeOfE1 : {typeOf (fold Arg1 Arg2) (mu R)}
ProgressClause : {value (fold Arg1 Arg2)}
Canonical : {value Arg1}
============================
 progresses (unfold (fold Arg1 Arg2))

Subgoal 2 is:
 progresses (unfold E1)

progress_unfold < search.
Subgoal 2:

Variables: E1 R E'
TypeOfE1 : {typeOf E1 (mu R)}
ProgressClause : {step E1 E'}
============================
 progresses (unfold E1)

progress_unfold < search.
Proof completed.
Abella < Theorem progress : 
forall E T, {typeOf E T} -> progresses E.


============================
 forall E T, {typeOf E T} -> progresses E

progress < induction on 1.

IH : forall E T, {typeOf E T}* -> progresses E
============================
 forall E T, {typeOf E T}@ -> progresses E

progress < intros Main.

Variables: E T
IH : forall E T, {typeOf E T}* -> progresses E
Main : {typeOf E T}@
============================
 progresses E

progress < TypeOfE1 : case Main.
Subgoal 1:

Variables: R E1
IH : forall E T, {typeOf E T}* -> progresses E
TypeOfE1 : {typeOf E1 (R (mu R))}*
============================
 progresses (fold E1 R)

Subgoal 2 is:
 progresses (unfold E1)

progress < apply IH to TypeOfE1.
Subgoal 1:

Variables: R E1
IH : forall E T, {typeOf E T}* -> progresses E
TypeOfE1 : {typeOf E1 (R (mu R))}*
H1 : progresses E1
============================
 progresses (fold E1 R)

Subgoal 2 is:
 progresses (unfold E1)

progress < backchain progress_fold.
Subgoal 2:

Variables: R E1
IH : forall E T, {typeOf E T}* -> progresses E
TypeOfE1 : {typeOf E1 (mu R)}*
============================
 progresses (unfold E1)

progress < apply IH to TypeOfE1.
Subgoal 2:

Variables: R E1
IH : forall E T, {typeOf E T}* -> progresses E
TypeOfE1 : {typeOf E1 (mu R)}*
H1 : progresses E1
============================
 progresses (unfold E1)

progress < backchain progress_unfold.
Proof completed.
Abella < Theorem preservation : 
forall Exp Exp' T, {typeOf Exp T} -> {step Exp Exp'} -> {typeOf Exp' T}.


============================
 forall Exp Exp' T, {typeOf Exp T} -> {step Exp Exp'} -> {typeOf Exp' T}

preservation < induction on 2.

IH : forall Exp Exp' T, {typeOf Exp T} -> {step Exp Exp'}* -> {typeOf Exp' T}
============================
 forall Exp Exp' T, {typeOf Exp T} -> {step Exp Exp'}@ -> {typeOf Exp' T}

preservation < intros TypeOf Main.

Variables: Exp Exp' T
IH : forall Exp Exp' T, {typeOf Exp T} -> {step Exp Exp'}* -> {typeOf Exp' T}
TypeOf : {typeOf Exp T}
Main : {step Exp Exp'}@
============================
 {typeOf Exp' T}

preservation < Step : case Main.
Subgoal 1:

Variables: Exp' T R
IH : forall Exp Exp' T, {typeOf Exp T} -> {step Exp Exp'}* -> {typeOf Exp' T}
TypeOf : {typeOf (unfold (fold Exp' R)) T}
Step : {value Exp'}*
============================
 {typeOf Exp' T}

Subgoal 2 is:
 {typeOf (fold E1' U2) T}

Subgoal 3 is:
 {typeOf (unfold E1') T}

preservation < Arg1_1 : case TypeOf (keep).
Subgoal 1:

Variables: Exp' R R1
IH : forall Exp Exp' T, {typeOf Exp T} -> {step Exp Exp'}* -> {typeOf Exp' T}
TypeOf : {typeOf (unfold (fold Exp' R)) (R1 (mu R1))}
Step : {value Exp'}*
Arg1_1 : {typeOf (fold Exp' R) (mu R1)}
============================
 {typeOf Exp' (R1 (mu R1))}

Subgoal 2 is:
 {typeOf (fold E1' U2) T}

Subgoal 3 is:
 {typeOf (unfold E1') T}

preservation < Arg2_1 : case Arg1_1 (keep).
Subgoal 1:

Variables: Exp' R1
IH : forall Exp Exp' T, {typeOf Exp T} -> {step Exp Exp'}* -> {typeOf Exp' T}
TypeOf : {typeOf (unfold (fold Exp' R1)) (R1 (mu R1))}
Step : {value Exp'}*
Arg1_1 : {typeOf (fold Exp' R1) (mu R1)}
Arg2_1 : {typeOf Exp' (R1 (mu R1))}
============================
 {typeOf Exp' (R1 (mu R1))}

Subgoal 2 is:
 {typeOf (fold E1' U2) T}

Subgoal 3 is:
 {typeOf (unfold E1') T}

preservation < search.
Subgoal 2:

Variables: T E1' E1 U2
IH : forall Exp Exp' T, {typeOf Exp T} -> {step Exp Exp'}* -> {typeOf Exp' T}
TypeOf : {typeOf (fold E1 U2) T}
Step : {step E1 E1'}*
============================
 {typeOf (fold E1' U2) T}

Subgoal 3 is:
 {typeOf (unfold E1') T}

preservation < TypeOf1 : case TypeOf.
Subgoal 2:

Variables: E1' E1 U2
IH : forall Exp Exp' T, {typeOf Exp T} -> {step Exp Exp'}* -> {typeOf Exp' T}
Step : {step E1 E1'}*
TypeOf1 : {typeOf E1 (U2 (mu U2))}
============================
 {typeOf (fold E1' U2) (mu U2)}

Subgoal 3 is:
 {typeOf (unfold E1') T}

preservation < apply IH to TypeOf1 Step.
Subgoal 2:

Variables: E1' E1 U2
IH : forall Exp Exp' T, {typeOf Exp T} -> {step Exp Exp'}* -> {typeOf Exp' T}
Step : {step E1 E1'}*
TypeOf1 : {typeOf E1 (U2 (mu U2))}
H1 : {typeOf E1' (U2 (mu U2))}
============================
 {typeOf (fold E1' U2) (mu U2)}

Subgoal 3 is:
 {typeOf (unfold E1') T}

preservation < search.
Subgoal 3:

Variables: T E1' E1
IH : forall Exp Exp' T, {typeOf Exp T} -> {step Exp Exp'}* -> {typeOf Exp' T}
TypeOf : {typeOf (unfold E1) T}
Step : {step E1 E1'}*
============================
 {typeOf (unfold E1') T}

preservation < TypeOf1 : case TypeOf.
Subgoal 3:

Variables: E1' E1 R
IH : forall Exp Exp' T, {typeOf Exp T} -> {step Exp Exp'}* -> {typeOf Exp' T}
Step : {step E1 E1'}*
TypeOf1 : {typeOf E1 (mu R)}
============================
 {typeOf (unfold E1') (R (mu R))}

preservation < apply IH to TypeOf1 Step.
Subgoal 3:

Variables: E1' E1 R
IH : forall Exp Exp' T, {typeOf Exp T} -> {step Exp Exp'}* -> {typeOf Exp' T}
Step : {step E1 E1'}*
TypeOf1 : {typeOf E1 (mu R)}
H1 : {typeOf E1' (mu R)}
============================
 {typeOf (unfold E1') (R (mu R))}

preservation < search.
Proof completed.
Abella < Theorem type_soundness : 
forall E E' T, {typeOf E T} -> {nstep E E'} -> progresses E'.


============================
 forall E E' T, {typeOf E T} -> {nstep E E'} -> progresses E'

type_soundness < induction on 2.

IH : forall E E' T, {typeOf E T} -> {nstep E E'}* -> progresses E'
============================
 forall E E' T, {typeOf E T} -> {nstep E E'}@ -> progresses E'

type_soundness < intros Main NStep.

Variables: E E' T
IH : forall E E' T, {typeOf E T} -> {nstep E E'}* -> progresses E'
Main : {typeOf E T}
NStep : {nstep E E'}@
============================
 progresses E'

type_soundness < Step1 : case NStep.
Subgoal 1:

Variables: E' T
IH : forall E E' T, {typeOf E T} -> {nstep E E'}* -> progresses E'
Main : {typeOf E' T}
============================
 progresses E'

Subgoal 2 is:
 progresses E'

type_soundness < backchain progress.
Subgoal 2:

Variables: E E' T E2
IH : forall E E' T, {typeOf E T} -> {nstep E E'}* -> progresses E'
Main : {typeOf E T}
Step1 : {step E E2}*
Step2 : {nstep E2 E'}*
============================
 progresses E'

type_soundness < TypeOfE2 : apply preservation to Main Step1.
Subgoal 2:

Variables: E E' T E2
IH : forall E E' T, {typeOf E T} -> {nstep E E'}* -> progresses E'
Main : {typeOf E T}
Step1 : {step E E2}*
Step2 : {nstep E2 E'}*
TypeOfE2 : {typeOf E2 T}
============================
 progresses E'

type_soundness < backchain IH with E = E2.
Proof completed.
Abella < 
</pre>
